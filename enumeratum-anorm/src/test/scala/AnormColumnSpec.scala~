package enumeratum

import scala.util.control.NonFatal

import anorm.{AnormException, SQL, SqlParser, TypeDoesNotMatch}, SqlParser.scalar

import org.scalatest.matchers.must.Matchers
import org.scalatest.wordspec.AnyWordSpec

import acolyte.jdbc.AcolyteDSL.withQueryResult
import acolyte.jdbc.Implicits._
import acolyte.jdbc.{RowList, RowLists}

final class AnormColumnSpec extends AnyWordSpec with Matchers {
  "Sensitive enum" should {
    "successfully parsed as Column" when {
      def spec[T <: Dummy](repr: String, expected: T) =
        repr in withQueryResult(RowLists.stringList :+ repr) { implicit con =>
          SQL("SELECT v").as(scalar[Dummy].single) mustEqual expected
        }

      spec("A", Dummy.A)
      spec("B", Dummy.B)
      spec("c", Dummy.c)
    }

    "not be parsed as Column from invalid String representation" when {
      def spec(title: String, repr: String) =
        title in withQueryResult(RowLists.stringList :+ repr) { implicit con =>
          try {
            SQL("SELECT v").as(scalar[Dummy].single)
            fail(s"Must not be successful: $repr")
          } catch {
            case NonFatal(cause) =>
              cause mustEqual AnormException(TypeDoesNotMatch(s"Invalid value: $repr").message)
          }
        }

      spec("a (!= A as sensitive)", "a")
      spec("b (!= B as sensitive)", "b")
      spec("C (!= c as sensitive)", "C")
    }

    "not be parsed as Column from non-String values" when {
      def spec(tpe: String, rowList: RowList[_]) =
        tpe in withQueryResult(rowList) { implicit con =>
          try {
            SQL("SELECT v").as(scalar[Dummy].single)
            fail(s"Must not be successful: $tpe")
          } catch {
            case NonFatal(cause) =>
              cause mustEqual AnormException(
                TypeDoesNotMatch(s"Column '.null' expected to be String; Found $tpe").message)
          }
        }

      spec("int", RowLists.intList :+ 1)
    }
  }
}
